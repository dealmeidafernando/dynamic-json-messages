const DJM=(()=>{const e={},s={};let n="",o="",t="",r=!0,d=!1;const i=async(e="",s)=>{o=e,n=o.substr(o.lastIndexOf("/")+1),await fetch(o).then(e=>e.json()).then(e=>{t=e}).catch(e=>console.log(`[DJM] Error loading "${o}": ${e.message}`)).finally(()=>{s&&"function"==typeof s&&s(t)})},a=new Worker(URL.createObjectURL(new Blob([`onmessage=${e=>{let s;!function(e,n){void 0===e.instance?(e.nestedNodes=[],e.savedInfo={},e.skipToNode={},e.dataAttribs={},e.dataIndex=0,e.retrievedResponseNodeLevel=0,e.retrievedResponseValueNodeLevel=0,s=e):s=e.instance,n({key:e.key,response:e.response,canAppendResponses:e.canAppendResponses})}(e.data,e=>{!function(e,n,o){let{jsonStringKey:t,reloaded:r,dataAttribs:d,dataIndex:i,retrievedResponseNodeLevel:a,retrievedResponseValueNodeLevel:l}=s;const{nestedNodes:p,jsonFileName:c,jsonStringLoaded:u,savedInfo:v,skipToNode:f}=s;""===n?M(t,0):function(s){if(void 0===d||!d["*DJM_canResponse"])return;if(void 0===d.response.length)throw new Error(`["${c}" >> "${e}"]\nAll 'response' nested properties must be enclosed as array.`);void 0===f[s]&&(f[s]={});const n=void 0===f[s][v.responseId];n&&h(s,v.responseId,0,0);const{parentResponseNodeLevel:o,returnedResponseValueNodeLevel:t}=function(e,s){let n,o,t,r;const d=f[e][v.responseId],i=v.lastResponseParentNode.response.length;for(let a=0;a<i;a++){v.lastResponseParentNode.response[a]["*isResponseLevel"]=!0;const l=v.lastResponseParentNode.response[a][e];if(l){const e=l.length;for(let i=0;i<e;i++)if(void 0===n&&(n=a),void 0===t&&(t=i),a===d.parentResponseNodeLevel&&i>d.returnedResponseNodeLevel||s&&i>=d.returnedResponseNodeLevel||a>d.parentResponseNodeLevel){o=a,r=i;break}}if(void 0!==o)break;a===i-1?(o=n,r=t,v.lastResponseParentNode.response[o]["*DJM_skipped"]=void 0,v.lastResponseParentNode.response[o][e][r]["*DJM_skipped"]=void 0):v.lastResponseParentNode.response[a]["*DJM_skipped"]=!0}return{parentResponseNodeLevel:o,returnedResponseValueNodeLevel:r}}(s,n);if(void 0===t)return;h(s,v.responseId,o,t),a=f[s][v.responseId].parentResponseNodeLevel,l=f[s][v.responseId].returnedResponseNodeLevel,d["*DJM_canResponse"]=d["*DJM_skipped"]=void 0,d["*DJM_returnedResponse"]=s,v.lastReturnedResponse=s,v.hasResponded=!0,p[p.length]=d,M(d.response,a,!0,d["*DJM_returnedResponse"])}(n);function R(e){d["*DJM_canResponse"]||(d=void 0,v.lastResponseParentNode=void 0),s.jsonStringKey=t,s.reloaded=r,s.nestedNodes.length=p.length,s.savedInfo=v,s.skipToNode=f,s.dataAttribs=d,s.dataIndex=i,s.retrievedResponseNodeLevel=a,s.retrievedResponseValueNodeLevel=l,postMessage({type:e,data:s})}function h(e,s,n,o){f[e][s]={parentResponseNodeLevel:n,returnedResponseNodeLevel:o}}function J(e,s,n){f[e]={sequenceNodeLevel:s,updateOnNextTime:n}}function _(e,s,n=!1){const o=e[s];return{exists:void 0!==o,value:o,parentLength:n?Object.values(e).length:void 0}}function M(s,n=0,h,D,g,q){try{if(!u)throw new Error(`["${c}" >> "${e}"]\nJSON file not loaded.`);if(void 0===s)throw new Error(`["${c}" >> "${e}"]\nThere's no data for the specified JSON key.`);i=n,d=s[i];const N=i,I=_(d,"sequence",!0),w=_(d,"response"),b=_(d,"*repeatResponse"),x=_(d,"*required"),$=_(d,"*alternate");let j=d&&void 0!==d["*DJM_shown"];const O=d&&void 0!==d["*DJM_finished"];let y=d&&void 0!==d["*DJM_skipped"];if(!j){if(I.exists){const s=d.sequence.length;if(void 0===s)throw new Error(`["${c}" >> "${e}"]\nAll 'sequence' nested nodes must be enclosed as array.`);if(0===s)throw new Error(`["${c}" >> "${e}"]\nAt least must exist one sequence nested node.`)}else if(w.exists){const s=d.response.length;if(void 0===s)throw new Error(`["${c}" >> "${e}"]\nAll 'response' nested nodes must be enclosed as array.`);if(0===s)throw new Error(`["${c}" >> "${e}"]\nAt least must exist one response value node on 'response' nested node.`)}else{const n=s.length;if(void 0===n)throw new Error(`["${c}" >> "${e}"]\nAll nodes must be enclosed as array.`);if(0===n)throw new Error(`["${c}" >> "${e}"]\nCan't exist empty nodes.`)}if(w.exists&&I.exists)throw new Error(`["${c}" >> "${e}"]\nNodes must not have both 'response' and 'sequence' properties at the same time.`);if(!w.exists&&b.exists)throw new Error(`["${c}" >> "${e}"]\nThe '*repeatResponse' property must exist on parent response nodes only.`);if(!w.exists&&x.exists)throw new Error(`["${c}" >> "${e}"]\nThe '*required' property must exist on parent response nodes only.`);if(!I.exists&&$.exists)throw new Error(`["${c}" >> "${e}"]\nThe '*alternate' property must exist on parent sequence nodes only.`);0===p.length&&(r&&(r=JSON.parse(JSON.stringify(r))),v.rootNodeIndex=++v.rootNodeIndex||0,a=0),v.resultObject=JSON.parse(JSON.stringify(d)),d["*DJM_shown"]=!1}if(O||(d["*DJM_finished"]=!1),w.exists&&(v.isRepeatResponse=void 0),w.exists&&d["*DJM_shown"]){d["*DJM_canResponse"]=void 0;const e=d.response.length;for(let s=0;s<e&&(i=s,d.response[s]["*DJM_finished"]||d.response[s]["*DJM_skipped"]);s++);if(v.canFlow)return p[p.length]=d,void M(d.response,i,!0,d["*DJM_returnedResponse"],!0);if(!v.hasResponded){let e=!1;for(let s=p.length-1;s>=0;s--){const n=p[s];if(n.sequence){const s=n["*DJM_sequenceId"];if(n["*alternate"])J(s,void 0!==f[s]?f[s].sequenceNodeLevel:0,!0);else{const o=n.sequence.length;for(let t=0;t<o;t++)if(y=void 0!==n.sequence[t]["*DJM_skipped"],j=void 0!==n.sequence[t]["*DJM_shown"],!y&&!j){J(`${s}:P`,t),e=!0;break}}}if(e)break}if(p.length=0,v.responseHasPendingAlternateFromParent=void 0,e)v.canFlow=!0,M(t,0);else{if(t.shift(),0===t.length)return v.rootNodeIndex=void 0,v.lastResponseParentNode=void 0,a=0,l=0,v.responseId=void 0,v.lastReturnedResponse=void 0,v.lastSequenceIsAlternate=void 0,v.canFlow=void 0,t=r,void M(t,0);M(t,0)}return}}if(h){const s=d[D].length;if(void 0===s)throw new Error(`["${c}" >> "${e}"]\nAll returned response value nested properties must be enclosed as array.`);for(let e=0;e<s&&(i=e,s>1&&l>0&&e<l&&(d[D][e]["*DJM_skipped"]=!0),d[D][e]["*DJM_finished"]||d[D][e]["*DJM_skipped"]);e++);return d["*DJM_shown"]=!0,p[p.length]=d,void M(d[D],i,!1,D,!0)}if(d["*DJM_shown"]&&I.exists||I.exists&&(1===I.parentLength||$.exists&&2===I.parentLength)){d["*DJM_shown"]=!0;let e=!1;v.responseHasPendingAlternateFromParent||(d["*DJM_sequenceId"]=`root:${v.rootNodeIndex}-parent_response:${a}-index:${N}-level:${p.length}`);const s=d["*DJM_sequenceId"],n=d["*alternate"]=!!+d["*alternate"];n&&(v.lastSequenceIsAlternate=!0,e=void 0!==f[s],e&&f[s].updateOnNextTime&&J(s,function(e){let s,n;void 0===f[e["*DJM_sequenceId"]]&&J(e["*DJM_sequenceId"],0);const o=e.sequence.length;for(let t=0;t<o;t++){if(void 0===s&&(s=t),t>f[e["*DJM_sequenceId"]].sequenceNodeLevel){n=t;break}t===o-1&&(n=s)}return n}(d)));const o=d.sequence.length;for(let t=0;t<o&&(i=t,n&&e&&t<f[s].sequenceNodeLevel&&(d.sequence[t]["*DJM_skipped"]=!0),void 0!==f[`${s}:P`]&&(t<f[`${s}:P`].sequenceNodeLevel?d.sequence[t]["*DJM_skipped"]=!0:f[`${s}:P`]=void 0),!d.sequence[t]["*DJM_canResponse"]&&(d.sequence[t]["*DJM_finished"]||d.sequence[t]["*DJM_skipped"]||d.sequence[t]["*DJM_done"]));t++);return v.responseHasPendingAlternateFromParent||(p[p.length]=d),void M(d.sequence,i,void 0,void 0,void 0,!0)}if(!d["*DJM_shown"]){if(v.resultObject.isSequence=q,q&&v.isAlternate&&(v.resultObject.isAlternate=!0,v.isAlternate=void 0),v.resultObject.isResponse=g,v.resultObject.response=g?D:void 0,w.exists&&(v.resultObject.hasResponse=!0),g&&v.isRepeatResponse&&(v.resultObject.isRepeatResponse=!0,v.isRepeatResponse=void 0),I.exists&&(v.resultObject.hasSequence=!0,v.resultObject.sequence=void 0),$.exists&&(+$.value&&(v.isAlternate=!0,v.resultObject.hasAlternate=!0),v.resultObject["*alternate"]=void 0),b.exists&&(+b.value&&(v.isRepeatResponse=!0,v.resultObject.hasRepeatResponse=!0),v.resultObject["*repeatResponse"]=void 0),x.exists){const e=x.value,s=e=>e&&e.constructor&&e.constructor===Object,n=!!+e;v.resultObject.hasRequired=n||s(e),v.resultObject["*required"]=void 0,v.requiredResult=v.resultObject.hasRequired&&n?v.resultObject:e}if(d["*DJM_shown"]=!0,I.exists||w.exists||(d["*DJM_finished"]=!0),I.exists)v.canFlow=void 0!==v.lastReturnedResponse;else if(w.exists){if(d["*DJM_canResponse"]=d["*DJM_skipped"]=!0,v.canFlow=void 0,v.hasResponded=void 0,v.responseId=d["*DJM_responseId"]=`root:${v.rootNodeIndex}-index:${N}-response:${a}-${void 0===v.responseId||void 0===v.lastReturnedResponse?"default":v.lastReturnedResponse}:${p.length}`,v.lastResponseParentNode=d,v.responseHasPendingAlternateFromParent=v.lastSequenceIsAlternate,o){const e=d.response.map(e=>Object.keys(e)).reduce((e,s)=>e.concat(s));v.resultObject.responses=e.filter((s,n)=>e.indexOf(s)===n)}return void R("result")}let e=!1,s=!1;for(let n=p.length-1;n>=0;n--){const o=p[n],t=void 0!==o.sequence,r=o["*alternate"],d=void 0!==o.response;if((g=o["*isResponseLevel"])&&!s){let e=0;const n=o[v.lastReturnedResponse].length;for(let t=0;t<n;t++)if(y=void 0!==o[v.lastReturnedResponse][t]["*DJM_skipped"],y&&e++,o[v.lastReturnedResponse][t]["*DJM_finished"]){s=!0;break}o["*DJM_finished"]=e+(s?1:0)===n}else if(t){e=!0;for(let s=o.sequence.length-1;s>=0&&(o.sequence[s]["*DJM_finished"]||o.sequence[s]["*DJM_skipped"]||o.sequence[s]["*DJM_done"]||o["*alternate"]&&!o.sequence[s]["*DJM_shown"]);s--)o["*DJM_finished"]=0===s,e=!o["*DJM_finished"]}else if(d)if(s)o["*DJM_done"]=!0;else{const e=o.response.length-1;o["*DJM_finished"]=o.response[e]["*DJM_finished"]||o.response[e]["*DJM_skipped"]}if(r&&(o["*DJM_finished"]||o["*DJM_skipped"])&&(currentSequenceId=o["*DJM_sequenceId"],J(currentSequenceId,void 0!==f[currentSequenceId]?f[currentSequenceId].sequenceNodeLevel:0,!0)),s&&e)break}const n=s&&!e;return(t[0]["*DJM_finished"]||t[0]["*DJM_skipped"]||n)&&t.shift(),n&&(v.responseId=void 0),v.responseHasPendingAlternateFromParent=void 0,a=0,l=0,p.length=0,0===t.length&&(v.rootNodeIndex=void 0,v.responseId=void 0,v.lastResponseParentNode=void 0,v.lastSequenceIsAlternate=void 0,t=r,r=void 0),void R("result")}}catch(e){v.resultObject=e.message,R("exception")}}}(e.key,e.response,e.canAppendResponses)})}}`],{type:"application/javascript"})));return{_LoadJSONFileAsync:i,_Run:async(l="",{response:p="",lock:c=!1,reset:u=!1}={})=>{let v,f;async function R(s){e[l].jsonStringKey=s,h()}async function h(){return new Promise(async(J,_)=>{if(v=v||J,f=f||_,""===t)return void f('First load "DJM._LoadJSONFileAsync()"');let M;if(u?p=(e[l]=s[l]=void 0)||"":s[l]&&""===p?(M=e[l]=s[l],s[l]=void 0):M=e[l],M){if(M.isLoadingJsonFile)return void setTimeout(()=>h(),0);if(c)return void sendResult(M.savedInfo.resultObject);if(M.savedInfo.requiredResult){if(""===p)return M.savedInfo.requiredResult.isRequired=(M.savedInfo.requiredResult.hasRequired=void 0)||!0,d&&(M.savedInfo.requiredResult.responses=M.savedInfo.resultObject.responses),void v(M.savedInfo.requiredResult);M.savedInfo.requiredResult=void 0}M.canPrepareReloaded?e[l].reloaded=t[l]:e[l].reloaded=void 0}a.postMessage(void 0===M?{key:l,jsonFileName:n,jsonStringLoaded:""!==t,jsonStringKey:t[l],response:p,canAppendResponses:d}:{key:l,instance:M,response:p,canAppendResponses:d}),a.onmessage=n=>{const{type:a,data:p}=n.data;if("result"===a){const{resultObject:n}=p.savedInfo,t=p.jsonStringKey.length;let a;if(n.isRepeatResponse?(s[l]={},d&&(p.savedInfo.resultObject.responses=e[l].savedInfo.resultObject.responses),s[l]=p,a=s[l].canPrepareReloaded&&s[l].reloaded,s[l].canPrepareReloaded=1===t):(e[l]=p,a=e[l].canPrepareReloaded&&e[l].reloaded,e[l].canPrepareReloaded=1===t),!a&&t<=1&&r){const n=0===t;s[l]?s[l].isLoadingJsonFile=!0:e[l].isLoadingJsonFile=!0,i(o,o=>{n&&(s[l]?s[l].jsonStringKey=o[l]:e[l].jsonStringKey=o[l]),s[l]?s[l].isLoadingJsonFile=void 0:e[l].isLoadingJsonFile=void 0})}v(n)}else if("recall"===a)e[l]=p,r?i(o,e=>R(e[l])):R(t[l]);else if("exception"===a){const{resultObject:s}=p.savedInfo;e[l]=p,f(s)}}})}return h().then(e=>e).catch(e=>{throw new Error(e)})},_Settings:({isRefreshable:e=!0,appendResponses:s=!1})=>{r=e,d=s},_IsJSONFileLoaded:""!==t}})();
